diff --git a/nova/conf/libvirt.py b/nova/conf/libvirt.py
index 297aaae8d2..9a311ee563 100644
--- a/nova/conf/libvirt.py
+++ b/nova/conf/libvirt.py
@@ -1355,7 +1355,7 @@ and ``gid`` must be specified.
 libvirt_remotefs_opts = [
     cfg.StrOpt('remote_filesystem_transport',
                default='ssh',
-               choices=('ssh', 'rsync'),
+               choices=('ssh', 'rsync', 'http'),
                help="""
 libvirt's transport method for remote file operations.
 
@@ -1366,7 +1366,22 @@ compute nodes, other method must be used for:
 * creating file on remote host
 * removing file from remote host
 * copying file to remote host
-""")
+"""),
+    cfg.IntOpt('file_server_port',
+               default=8099,
+               min=1,
+               help='TCP port of the remote file server used by the http '
+                    'RemoteFilesystem driver.'),
+    cfg.IntOpt('file_server_chunk_size_mb',
+               default=50,
+               min=1,
+               help='Chunk size in MiB for HTTP uploads in the http '
+                    'RemoteFilesystem driver.'),
+    cfg.IntOpt('file_server_read_timeout',
+               default=900,
+               min=1,
+               help='Read timeout in seconds for HTTP operations in the http '
+                    'RemoteFilesystem driver.'),
 ]
 
 libvirt_volume_vzstorage_opts = [
diff --git a/nova/virt/libvirt/volume/remotefs.py b/nova/virt/libvirt/volume/remotefs.py
index 8ddcaa1fcc..ae91499794 100644
--- a/nova/virt/libvirt/volume/remotefs.py
+++ b/nova/virt/libvirt/volume/remotefs.py
@@ -15,6 +15,13 @@
 
 import abc
 import os
+import math
+import gzip
+from typing import Tuple
+
+import requests
+from requests.adapters import HTTPAdapter
+from urllib3.util.retry import Retry
 
 from oslo_concurrency import processutils
 from oslo_log import log as logging
@@ -30,6 +37,42 @@ LOG = logging.getLogger(__name__)
 CONF = nova.conf.CONF
 
 
+def _parse_remote_dst(dst: str) -> Tuple[str, str]:
+    # Expected format: "<host>:<absolute_path>"
+    # Example: "10.149.132.154:/var/snap/openstack-hypervisor/common/lib/nova/instances/.../disk"
+    if ":" not in dst:
+        raise ValueError(f"Invalid remote path format, expected 'host:/abs/path', got: {dst}")
+    host, path = dst.split(":", 1)
+    if not path.startswith("/"):
+        raise ValueError(f"Destination path must be absolute, got: {path}")
+    return host, path
+
+
+def _build_base_url(host: str) -> str:
+    port = getattr(CONF.libvirt, "file_server_port", None)
+    safe_host = utils.safe_ip_format(host)
+    return f"http://{safe_host}:{port}"
+
+
+def _new_http_session() -> requests.Session:
+    # Robust retry behavior for idempotent requests; chunk uploads are also safe to retry
+    # because we use deterministic chunk_index names server-side.
+    session = requests.Session()
+    retry = Retry(
+        total=10,
+        connect=5,
+        read=5,
+        backoff_factor=0.5,
+        status_forcelist=(500, 502, 503, 504),
+        allowed_methods=frozenset(["GET", "POST", "PUT", "DELETE"]),
+        raise_on_status=False,
+    )
+    adapter = HTTPAdapter(max_retries=retry, pool_maxsize=20)
+    session.mount("http://", adapter)
+    session.mount("https://", adapter)
+    return session
+
+
 def mount_share(mount_path, export_path,
                 export_type, options=None):
     """Mount a remote export to mount_path.
@@ -314,3 +357,122 @@ class RsyncDriver(RemoteFilesystemDriver):
             args.append('--compress')
         processutils.execute(
             *args, on_execute=on_execute, on_completion=on_completion)
+
+
+class HttpDriver(RemoteFilesystemDriver):
+    """HTTP transport driver implementing RemoteFilesystemDriver API."""
+
+    def __init__(self):
+        chunk_mb = getattr(CONF.libvirt, "file_server_chunk_size_mb", None)
+        self._chunk_size = int(chunk_mb) * 1024 * 1024
+        read_timeout = getattr(CONF.libvirt, "file_server_read_timeout", None)
+        self._timeout = (5, int(read_timeout))
+        self._session = _new_http_session()
+
+
+    def create_file(self, host, dst_path, on_execute=None, on_completion=None):
+        LOG.debug("[http] Creating file %s on remote host %s", dst_path, host)
+        base = _build_base_url(host)
+        url = f"{base}/fs/create-file"
+        if on_execute:
+            on_execute(None)
+        resp = self._session.post(url, json={"dst_path": dst_path}, timeout=self._timeout)
+        self._raise_for_status(resp, url)
+        if on_completion:
+            on_completion(None, None)
+
+    def remove_file(self, host, dst_path, on_execute=None, on_completion=None):
+        LOG.debug("[http] Removing file %s on remote host %s", dst_path, host)
+        base = _build_base_url(host)
+        url = f"{base}/fs/remove-file"
+        if on_execute:
+            on_execute(None)
+        resp = self._session.delete(url, params={"dst_path": dst_path}, timeout=self._timeout)
+        self._raise_for_status(resp, url)
+        if on_completion:
+            on_completion(None, None)
+
+    def create_dir(self, host, dst_path, on_execute=None, on_completion=None):
+        LOG.debug("[http] Creating directory %s on remote host %s", dst_path, host)
+        base = _build_base_url(host)
+        url = f"{base}/fs/create-dir"
+        if on_execute:
+            on_execute(None)
+        resp = self._session.post(url, json={"dst_path": dst_path}, timeout=self._timeout)
+        self._raise_for_status(resp, url)
+        if on_completion:
+            on_completion(None, None)
+
+    def remove_dir(self, host, dst_path, on_execute=None, on_completion=None):
+        LOG.debug("[http] Removing directory %s on remote host %s", dst_path, host)
+        base = _build_base_url(host)
+        url = f"{base}/fs/remove-dir"
+        if on_execute:
+            on_execute(None)
+        resp = self._session.delete(url, params={"dst_path": dst_path}, timeout=self._timeout)
+        self._raise_for_status(resp, url)
+        if on_completion:
+            on_completion(None, None)
+
+
+    def copy_file(self, src, dst, on_execute=None, on_completion=None, compression=True):
+        LOG.debug("[http] Copying file %s to %s", src, dst)
+
+        host, dst_path = _parse_remote_dst(dst)
+        base = _build_base_url(host)
+
+        init_url = f"{base}/upload/init"
+        total_size = os.path.getsize(src)
+        init_params = {
+            "destination_path": dst_path,
+            "total_size": total_size,
+        }
+        if compression:
+            init_params["compression"] = "gzip"
+        if on_execute:
+            on_execute(None)
+        init_resp = self._session.post(init_url, json=init_params, timeout=self._timeout)
+        self._raise_for_status(init_resp, init_url)
+        upload_id = init_resp.json()["upload_id"]
+
+        total_chunks = int(math.ceil(float(total_size) / float(self._chunk_size)))
+        put_url = f"{base}/upload/{upload_id}"
+
+        with open(src, "rb") as f:
+            for chunk_index in range(total_chunks):
+                data = f.read(self._chunk_size)
+                if not data:
+                    break
+                params = {
+                    "chunk_index": chunk_index,
+                    "total_chunks": total_chunks,
+                }
+                body = gzip.compress(data) if compression else data
+                headers = {"Content-Encoding": "gzip"} if compression else None
+                resp = self._session.put(
+                    put_url,
+                    params=params,
+                    data=body,
+                    headers=headers,
+                    timeout=self._timeout,
+                )
+                self._raise_for_status(resp, put_url)
+
+        finalize_url = f"{base}/upload/finalize"
+        fin_resp = self._session.post(finalize_url, json={"upload_id": upload_id}, timeout=self._timeout)
+        self._raise_for_status(fin_resp, finalize_url)
+        if on_completion:
+            on_completion(None, None)
+
+    def _raise_for_status(self, resp: requests.Response, url: str) -> None:
+        if 200 <= resp.status_code < 300:
+            return
+        msg = f"HttpDriver HTTP error {resp.status_code} on {url}"
+        try:
+            payload = resp.json()
+            msg += f": {payload}"
+        except Exception:
+            if resp.text:
+                msg += f": {resp.text[:1024]}"
+        LOG.error(msg)
+        resp.raise_for_status()
