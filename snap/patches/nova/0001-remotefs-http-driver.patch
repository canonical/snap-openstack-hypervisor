diff --git a/nova/conf/libvirt.py b/nova/conf/libvirt.py
index 0746d4040a..274c6d45a4 100644
--- a/nova/conf/libvirt.py
+++ b/nova/conf/libvirt.py
@@ -1384,7 +1384,7 @@ and ``gid`` must be specified.
 libvirt_remotefs_opts = [
     cfg.StrOpt('remote_filesystem_transport',
                default='ssh',
-               choices=('ssh', 'rsync'),
+               choices=('ssh', 'rsync', 'http'),
                help="""
 libvirt's transport method for remote file operations.
 
@@ -1395,7 +1395,26 @@ compute nodes, other method must be used for:
 * creating file on remote host
 * removing file from remote host
 * copying file to remote host
-""")
+"""),
+    cfg.IntOpt('file_server_port',
+               default=10099,
+               min=1024,
+               help='TCP port of the remote file server used by the http '
+                    'RemoteFilesystem driver.'),
+    cfg.IntOpt('file_server_read_timeout',
+               default=900,
+               min=5,
+               help='Read timeout in seconds for HTTP operations in the http '
+                    'RemoteFilesystem driver. Must be at least 5 seconds.'),
+    cfg.StrOpt('file_server_ca_file',
+               help='Path to a CA bundle file to verify the HTTPS file '
+                    'server. If set, verification is enabled using this file.'),
+    cfg.StrOpt('file_server_client_cert_file',
+               help='Path to client certificate file for mutual TLS to the '
+                    'file server.'),
+    cfg.StrOpt('file_server_client_key_file',
+               help='Path to client private key file for mutual TLS to the '
+                     'file server.'),
 ]
 
 libvirt_volume_vzstorage_opts = [
diff --git a/nova/virt/libvirt/volume/remotefs.py b/nova/virt/libvirt/volume/remotefs.py
index 8ddcaa1fcc..8096c77903 100644
--- a/nova/virt/libvirt/volume/remotefs.py
+++ b/nova/virt/libvirt/volume/remotefs.py
@@ -24,6 +24,8 @@ from oslo_utils import importutils
 import nova.conf
 import nova.privsep.fs
 from nova import utils
+from nova.virt.libvirt.volume.remotefs_http import HttpDriver as _HttpDriverImpl
+HttpDriver = _HttpDriverImpl
 
 LOG = logging.getLogger(__name__)
 
diff --git a/nova/virt/libvirt/volume/remotefs_http.py b/nova/virt/libvirt/volume/remotefs_http.py
new file mode 100644
index 0000000000..0c1126646f
--- /dev/null
+++ b/nova/virt/libvirt/volume/remotefs_http.py
@@ -0,0 +1,156 @@
+import os
+import ssl
+import tempfile
+from typing import Tuple
+import posixpath
+from oslo_log import log as logging
+
+import nova.conf
+from urllib.parse import urlsplit
+from webdav4.client import ResourceAlreadyExists, ForbiddenOperation
+
+
+LOG = logging.getLogger(__name__)
+CONF = nova.conf.CONF
+
+LOG.debug("[webdav] remotefs_http module loaded")
+
+
+def _parse_remote_dst(dst: str) -> Tuple[str, str]:
+    """Split a remote destination of the form \"<host>:<absolute_path>\"."""
+    if ":" not in dst:
+        raise ValueError(
+            f"Invalid remote path format, expected 'host:/abs/path', got: {dst}"
+        )
+    parsed = urlsplit(f"scheme://{dst}")
+    host = parsed.hostname
+    path = parsed.path
+
+    if not host or not path:
+        raise ValueError(
+            f"Invalid remote path format, expected 'host:/abs/path', got: {dst}"
+        )
+    if not path.startswith("/"):
+        raise ValueError(f"Destination path must be absolute, got: {path}")
+    return host, path
+
+
+def _ensure_trailing_slash(path: str) -> str:
+    if not path or path.endswith("/"):
+        return path
+    return f"{path}/"
+
+
+def _base_url(host: str) -> str:
+    port = getattr(CONF.libvirt, "file_server_port", 10099)
+    return f"https://{host}:{port}"
+
+
+def _new_client(host: str):
+    # Lazy import to keep dependency surface localized
+    from webdav4.client import Client
+
+    base_url = _base_url(host)
+
+    # TLS verification and client certs for mTLS
+    ca_file = getattr(CONF.libvirt, "file_server_ca_file", None) or True
+    cert_file = getattr(CONF.libvirt, "file_server_client_cert_file", "") or None
+    key_file = getattr(CONF.libvirt, "file_server_client_key_file", "") or None
+
+    kwargs = {}
+    ssl_context = ssl.create_default_context(cafile=ca_file)
+    kwargs["verify"] = ssl_context
+
+    if cert_file and key_file:
+        kwargs["cert"] = (cert_file, key_file)
+
+    body_timeout = CONF.libvirt.file_server_read_timeout
+    kwargs["timeout"] = (5, body_timeout)
+
+    # Disable proxy usage from environment variables; httpx (used by webdav4)
+    # will otherwise try to use HTTP_PROXY/HTTPS_PROXY.
+    kwargs["trust_env"] = False
+
+    return Client(base_url, **kwargs)
+
+
+def _ensure_remote_dirs(client, path: str) -> None:
+    """Ensure that each component of the remote path exists."""
+    if not path:
+        return
+
+    components = [segment for segment in path.strip("/").split("/") if segment]
+    current = ""
+    for segment in components:
+        current = posixpath.join(current, segment) if current else segment
+        current_dir = _ensure_trailing_slash(current)
+        if client.exists(current_dir):
+            continue
+        try:
+            client.mkdir(current_dir)
+            LOG.debug("[webdav] mkdir %s", current_dir)
+        except ResourceAlreadyExists:
+            # Another worker may have created this path between exists() and mkdir()
+            continue
+        except ForbiddenOperation:
+            LOG.warning("[webdav] forbidden to mkdir %s, stopping directory creation", current_dir)
+            break
+        except Exception as exc:
+            LOG.error("[webdav] mkdir %s failed: %s", current_dir, exc, exc_info=True)
+            raise
+
+class HttpDriver:
+    """HTTP(WebDAV) transport driver implementing RemoteFilesystemDriver API."""
+
+    def create_file(self, host, dst_path, on_execute=None, on_completion=None):
+        LOG.debug("[webdav] create file %s on %s", dst_path, host)
+        client = _new_client(host)
+        webdav_path = dst_path
+
+        parent = os.path.dirname(webdav_path.rstrip("/"))
+        _ensure_remote_dirs(client, parent)
+
+        # PUT empty file using a temporary zero-byte file
+        with tempfile.NamedTemporaryFile() as tmp:
+            client.upload_file(tmp.name, webdav_path, overwrite=True)
+
+    def remove_file(self, host, dst_path, on_execute=None, on_completion=None):
+        LOG.debug("[webdav] remove file %s on %s", dst_path, host)
+        client = _new_client(host)
+        webdav_path = dst_path
+        client.remove(webdav_path)
+
+    def create_dir(self, host, dst_path, on_execute=None, on_completion=None):
+        LOG.debug("[webdav] create dir %s on %s", dst_path, host)
+        client = _new_client(host)
+        webdav_path = _ensure_trailing_slash(dst_path.rstrip("/"))
+
+        parent = os.path.dirname(webdav_path)
+        _ensure_remote_dirs(client, parent)
+
+        try:
+            client.mkdir(webdav_path)
+            LOG.debug("[webdav] mkdir final %s", webdav_path)
+        except ResourceAlreadyExists:
+            # Directory already exists, safe to ignore
+            pass
+
+    def remove_dir(self, host, dst_path, on_execute=None, on_completion=None):
+        LOG.debug("[webdav] remove dir %s on %s", dst_path, host)
+        client = _new_client(host)
+        webdav_path = _ensure_trailing_slash(dst_path.rstrip("/"))
+        LOG.debug("[webdav] remove_dir target path=%s", webdav_path)
+        client.remove(webdav_path)
+
+    def copy_file(self, src, dst, on_execute=None, on_completion=None, compression=True):
+        # compression ignored: WebDAV handles full-stream PUTs natively
+        LOG.debug("[webdav] upload %s to %s", src, dst)
+
+        host, dst_path = _parse_remote_dst(dst)
+        client = _new_client(host)
+        webdav_path = dst_path
+
+        parent = os.path.dirname(webdav_path.rstrip("/"))
+        _ensure_remote_dirs(client, parent)
+
+        client.upload_file(src, webdav_path, overwrite=True)
